#include<stdio.h>
#include<Windows.h>
#pragma warning(disable:4996)


/*
1. 有一个二维数组，数组的每行从左到右是递增的，每列从上到下是递增的，在这样的数组中查找一个数字是否存在。
要求：时间复杂度小于O(N);

1 4 6
2 5 7
3 6 9
思路：传统的在这样的二维数组中找一个数字的方法都是从头到尾将所有的数字遍历一次，这样的话时间复杂度是O(n),不符合题目要求；
      要让时间复杂度小于O（n），意思就是不能从头到尾遍历，我们可以重新选择一个起点。（这样一个二维数组开始查找的时候有五个选择，
	  中间，左上角，右上角，左下角，右下角。但是显而易见，从中间或者左上角，右下角开始的话，比他大或者小的方向比较多，遍历起来很麻烦。
	  而右上角和左下角比较方便，一个方向是比他大的，一个方向是比他小的。此次，我们选择右上角来作为起始位置。

	  
*/

int YangSquare(int a[][3], int x, int y,int z)
{
	int i = 0; int j = 2;
	while (i<x&&j>=0)
	{
		if (z > a[i][j])
		{
			i++;
		}
		else if (z < a[i][j])
		{
			j--;
		}
		else
		{
			return z;
		}
	}
	return 0;
}
int main()
{
	int z = 0;
	int a[3][3] = { 1, 4, 6,
		            2, 5, 7,
		            3, 6, 9 };
	printf("请输入你要查找的数：\n");
	scanf("%d", &z);
	printf("%d\n",YangSquare(a, 3, 3,z));
	system("pause");
	return 0;
}